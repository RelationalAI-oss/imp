use runtime::{Direction, Kind};
use bootstrap::{Binding, Value, KindedBinding};

#[pub]
over_bindings -> Vec<(Binding, Direction)>
  = sort ++ (" "+)

sort -> (Binding, Direction)
  = d:sort_direction v:named_variable { (v, d) }

sort_direction -> Direction
  = descending:"-"? {
    match descending {
      Some(_) => Direction::Descending,
      None    => Direction::Ascending
    }
  }

#[pub]
kinded_binding -> KindedBinding
  = kinded_variable / b:binding { (b, None) }

binding -> Binding
  = unbound_variable / named_variable
  / constant_id / constant_text / constant_number

unbound_variable -> Binding
  = "_" { Binding::Unbound }

kinded_variable -> KindedBinding
  = n:name k:kind? { (Binding::Variable(n), k) }

named_variable -> Binding
  = n:name kind? { Binding::Variable(n) }

constant_id -> Binding
  = "#" id:number_u64 { Binding::Constant(Value::Id(id)) }

constant_text -> Binding
  = s:string_literal { Binding::Constant(Value::Text(s)) }

constant_number -> Binding
  = n:number_f64 { Binding::Constant(Value::Number(n)) }

// No escaping for now.
string_literal -> String
  = "\"" s:string_literal_contents "\"" { s }

string_literal_contents -> String
  = [^"]* { match_str.to_owned() }

kind -> Kind
  = ":id"     { Kind::Id }
  / ":text"   { Kind::Text }
  / ":number" { Kind::Number }
  / ":" identifier { panic!("Unknown kind: {:?}", match_str) }

name -> String
  = "?" identifier { match_str.to_owned() }

identifier = [A-Za-z0-9]+

/** Numbers **/

number_u64 -> u64
  = integer_digits { match_str.parse::<u64>().unwrap() }

number_f64 -> f64
  = integer_digits { match_str.parse::<f64>().unwrap() }

decimal_digits = [0-9]+ ("." [0-9]+)? { () }
integer_digits = [0-9]+