block(`dom) {
 export(`{ 
   node(node) -> 
     string(node).
   
   node_by_id[id] = node ->
     string(id), string(node), node(node).
 
   parent[node] = parent ->
     string(node), string(parent), node(node), node(parent).
      
   position[node] = position -> 
     string(node), node(node), int(position). 
     
   tag[node] = tag -> // defaults to "div"
     string(node), node(node), string(tag).
     
   attribute[node, key] = val ->
     string(node), node(node), string(key), string(val).
 
   style[node, key] = val ->
     string(node), node(node), string(key), string(val).
 
   text[node] = text ->
     string(node), node(node), string(text).
     
   event(event) -> 
     string(event).
   
   event_by_name[name] = event ->
     string(name), string(event), event(event).
 
   listen_to(node, event) ->
     string(node), string(event), node(node), event(event).
     
   // events only constrain string(node) because node might already be deleted
 
   click(node) ->
     string(node). 
 
   key_down[node] = key ->
     string(node), int(key).
     
   change[node] = text ->
     string(node), string(text).
  }),
  clauses(`{
    lang:pulse(`click).
    lang:pulse(`key_down).
    lang:pulse(`change).
    
    node("root").
    
    event("click").
    event("key_down").
    event("change").
    
    // every node except the root must have a parent
    node(node) -> 
      node = "root"; parent[node] = _.
      
    // no two nodes at same position
    parent[child1] = parent[child2], child1 != child2 ->
      position[child1] != position[child2].
    
    // TODO this doesn't compile
    // no gaps in position
    // position[child1] = p, p > 0 ->
    //  parent[child2] = parent[child1],
    //  position[child2] = p-1.
      
    // can EITHER set text OR have children (because setting node.textContent deletes any existing children)
    text[node] = _ ->
      !parent[_] = node. 
  })
} <-- .
